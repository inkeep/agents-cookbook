// src/index.ts
import { getGlobalLogger as getGlobalLogger2, LangfuseOtelSpanAttributes as LangfuseOtelSpanAttributes2 } from "@langfuse/core";
import {
  trace as trace2,
  context,
  SpanStatusCode
} from "@opentelemetry/api";

// src/attributes.ts
import { LangfuseOtelSpanAttributes } from "@langfuse/core";
function createTraceAttributes({
  name,
  userId,
  sessionId,
  version,
  release,
  input,
  output,
  metadata,
  tags,
  environment,
  public: isPublic
} = {}) {
  const attributes = {
    [LangfuseOtelSpanAttributes.TRACE_NAME]: name,
    [LangfuseOtelSpanAttributes.TRACE_USER_ID]: userId,
    [LangfuseOtelSpanAttributes.TRACE_SESSION_ID]: sessionId,
    [LangfuseOtelSpanAttributes.VERSION]: version,
    [LangfuseOtelSpanAttributes.RELEASE]: release,
    [LangfuseOtelSpanAttributes.TRACE_INPUT]: _serialize(input),
    [LangfuseOtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),
    [LangfuseOtelSpanAttributes.TRACE_TAGS]: tags,
    [LangfuseOtelSpanAttributes.ENVIRONMENT]: environment,
    [LangfuseOtelSpanAttributes.TRACE_PUBLIC]: isPublic,
    ..._flattenAndSerializeMetadata(metadata, "trace")
  };
  return Object.fromEntries(
    Object.entries(attributes).filter(([_, v]) => v != null)
  );
}
function createObservationAttributes(type, attributes) {
  const {
    metadata,
    input,
    output,
    level,
    statusMessage,
    version,
    completionStartTime,
    model,
    modelParameters,
    usageDetails,
    costDetails,
    prompt
  } = attributes;
  let otelAttributes = {
    [LangfuseOtelSpanAttributes.OBSERVATION_TYPE]: type,
    [LangfuseOtelSpanAttributes.OBSERVATION_LEVEL]: level,
    [LangfuseOtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,
    [LangfuseOtelSpanAttributes.VERSION]: version,
    [LangfuseOtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),
    [LangfuseOtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),
    [LangfuseOtelSpanAttributes.OBSERVATION_MODEL]: model,
    [LangfuseOtelSpanAttributes.OBSERVATION_USAGE_DETAILS]: _serialize(usageDetails),
    [LangfuseOtelSpanAttributes.OBSERVATION_COST_DETAILS]: _serialize(costDetails),
    [LangfuseOtelSpanAttributes.OBSERVATION_COMPLETION_START_TIME]: _serialize(completionStartTime),
    [LangfuseOtelSpanAttributes.OBSERVATION_MODEL_PARAMETERS]: _serialize(modelParameters),
    ...prompt && !prompt.isFallback ? {
      [LangfuseOtelSpanAttributes.OBSERVATION_PROMPT_NAME]: prompt.name,
      [LangfuseOtelSpanAttributes.OBSERVATION_PROMPT_VERSION]: prompt.version
    } : {},
    ..._flattenAndSerializeMetadata(metadata, "observation")
  };
  return Object.fromEntries(
    Object.entries(otelAttributes).filter(([_, v]) => v != null)
  );
}
function _serialize(obj) {
  try {
    if (typeof obj === "string") return obj;
    return obj != null ? JSON.stringify(obj) : void 0;
  } catch {
    return "<failed to serialize>";
  }
}
function _flattenAndSerializeMetadata(metadata, type) {
  const prefix = type === "observation" ? LangfuseOtelSpanAttributes.OBSERVATION_METADATA : LangfuseOtelSpanAttributes.TRACE_METADATA;
  const metadataAttributes = {};
  if (metadata === void 0 || metadata === null) {
    return metadataAttributes;
  }
  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    const serialized = _serialize(metadata);
    if (serialized) {
      metadataAttributes[prefix] = serialized;
    }
  } else {
    for (const [key, value] of Object.entries(metadata)) {
      const serialized = typeof value === "string" ? value : _serialize(value);
      if (serialized) {
        metadataAttributes[`${prefix}.${key}`] = serialized;
      }
    }
  }
  return metadataAttributes;
}

// src/tracerProvider.ts
import {
  getGlobalLogger,
  LANGFUSE_SDK_VERSION,
  LANGFUSE_TRACER_NAME
} from "@langfuse/core";
import { trace } from "@opentelemetry/api";
var LANGFUSE_GLOBAL_SYMBOL = Symbol.for("langfuse");
function createState() {
  return {
    isolatedTracerProvider: null
  };
}
function getGlobalState() {
  const initialState = createState();
  try {
    const g = globalThis;
    if (typeof g !== "object" || g === null) {
      getGlobalLogger().warn(
        "globalThis is not available, using fallback state"
      );
      return initialState;
    }
    if (!g[LANGFUSE_GLOBAL_SYMBOL]) {
      Object.defineProperty(g, LANGFUSE_GLOBAL_SYMBOL, {
        value: initialState,
        writable: false,
        // lock the slot (not the contents)
        configurable: false,
        enumerable: false
      });
    }
    return g[LANGFUSE_GLOBAL_SYMBOL];
  } catch (err) {
    if (err instanceof Error) {
      getGlobalLogger().error(`Failed to access global state: ${err.message}`);
    } else {
      getGlobalLogger().error(`Failed to access global state: ${String(err)}`);
    }
    return initialState;
  }
}
function setLangfuseTracerProvider(provider) {
  getGlobalState().isolatedTracerProvider = provider;
}
function getLangfuseTracerProvider() {
  const { isolatedTracerProvider } = getGlobalState();
  if (isolatedTracerProvider) return isolatedTracerProvider;
  return trace.getTracerProvider();
}
function getLangfuseTracer() {
  return getLangfuseTracerProvider().getTracer(
    LANGFUSE_TRACER_NAME,
    LANGFUSE_SDK_VERSION
  );
}

// src/spanWrapper.ts
var LangfuseBaseObservation = class {
  constructor(params) {
    this.otelSpan = params.otelSpan;
    this.id = params.otelSpan.spanContext().spanId;
    this.traceId = params.otelSpan.spanContext().traceId;
    this.type = params.type;
    if (params.attributes) {
      this.otelSpan.setAttributes(
        createObservationAttributes(params.type, params.attributes)
      );
    }
  }
  /** Gets the Langfuse OpenTelemetry tracer instance */
  get tracer() {
    return getLangfuseTracer();
  }
  /**
   * Ends the observation, marking it as complete.
   *
   * @param endTime - Optional end time, defaults to current time
   */
  end(endTime) {
    this.otelSpan.end(endTime);
  }
  updateOtelSpanAttributes(attributes) {
    this.otelSpan.setAttributes(
      createObservationAttributes(this.type, attributes)
    );
  }
  /**
   * Updates the parent trace with new attributes.
   *
   * This sets trace-level attributes that apply to the entire trace,
   * not just this specific observation.
   *
   * @param attributes - Trace attributes to set
   * @returns This observation for method chaining
   */
  updateTrace(attributes) {
    this.otelSpan.setAttributes(createTraceAttributes(attributes));
    return this;
  }
  startObservation(name, attributes, options) {
    const { asType = "span" } = options || {};
    return startObservation(name, attributes, {
      asType,
      // typecast necessary as ts cannot narrow the type correctly
      parentSpanContext: this.otelSpan.spanContext()
    });
  }
};
var LangfuseSpan = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "span" });
  }
  /**
   * Updates this span with new attributes.
   *
   * @param attributes - Span attributes to set
   * @returns This span for method chaining
   *
   * @example
   * ```typescript
   * span.update({
   *   output: { result: 'success' },
   *   level: 'DEFAULT',
   *   metadata: { duration: 150 }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseAgent = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "agent" });
  }
  /**
   * Updates this agent observation with new attributes.
   *
   * @param attributes - Agent attributes to set
   * @returns This agent for method chaining
   *
   * @example
   * ```typescript
   * agent.update({
   *   output: {
   *     taskCompleted: true,
   *     iterationsUsed: 5,
   *     toolsInvoked: ['web-search', 'calculator', 'summarizer'],
   *     finalResult: 'Research completed with high confidence'
   *   },
   *   metadata: {
   *     efficiency: 0.85,
   *     qualityScore: 0.92,
   *     resourcesConsumed: { tokens: 15000, apiCalls: 12 }
   *   }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseTool = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "tool" });
  }
  /**
   * Updates this tool observation with new attributes.
   *
   * @param attributes - Tool attributes to set
   * @returns This tool for method chaining
   *
   * @example
   * ```typescript
   * tool.update({
   *   output: {
   *     result: searchResults,
   *     count: searchResults.length,
   *     relevanceScore: 0.89,
   *     executionTime: 1250
   *   },
   *   metadata: {
   *     cacheHit: false,
   *     apiCost: 0.025,
   *     rateLimitRemaining: 950
   *   }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseChain = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "chain" });
  }
  /**
   * Updates this chain observation with new attributes.
   *
   * @param attributes - Chain attributes to set
   * @returns This chain for method chaining
   *
   * @example
   * ```typescript
   * chain.update({
   *   output: {
   *     stepsCompleted: 5,
   *     stepsSuccessful: 4,
   *     finalResult: processedData,
   *     pipelineEfficiency: 0.87
   *   },
   *   metadata: {
   *     bottleneckStep: 'data-validation',
   *     parallelizationOpportunities: ['step-2', 'step-3'],
   *     optimizationSuggestions: ['cache-intermediate-results']
   *   }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseRetriever = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "retriever" });
  }
  /**
   * Updates this retriever observation with new attributes.
   *
   * @param attributes - Retriever attributes to set
   * @returns This retriever for method chaining
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseEvaluator = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "evaluator" });
  }
  /**
   * Updates this evaluator observation with new attributes.
   *
   * @param attributes - Evaluator attributes to set
   * @returns This evaluator for method chaining
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseGuardrail = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "guardrail" });
  }
  /**
   * Updates this guardrail observation with new attributes.
   *
   * @param attributes - Guardrail attributes to set
   * @returns This guardrail for method chaining
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseGeneration = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "generation" });
  }
  update(attributes) {
    this.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseEmbedding = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "embedding" });
  }
  /**
   * Updates this embedding observation with new attributes.
   *
   * @param attributes - Embedding attributes to set
   * @returns This embedding for method chaining
   */
  update(attributes) {
    this.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseEvent = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "event" });
    this.otelSpan.end(params.timestamp);
  }
};

// src/index.ts
import { LangfuseOtelSpanAttributes as LangfuseOtelSpanAttributes3 } from "@langfuse/core";
function createOtelSpan(params) {
  return getLangfuseTracer().startSpan(
    params.name,
    { startTime: params.startTime },
    createParentContext(params.parentSpanContext)
  );
}
function createParentContext(parentSpanContext) {
  if (!parentSpanContext) return;
  return trace2.setSpanContext(context.active(), parentSpanContext);
}
function wrapPromise(promise, span, endOnExit) {
  return promise.then(
    (value) => {
      if (endOnExit !== false) {
        span.end();
      }
      return value;
    },
    (err) => {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: err instanceof Error ? err.message : "Unknown error"
      });
      if (endOnExit !== false) {
        span.end();
      }
      throw err;
    }
  );
}
function startObservation(name, attributes, options) {
  var _a;
  const { asType = "span", ...observationOptions } = options || {};
  const otelSpan = createOtelSpan({
    name,
    ...observationOptions
  });
  switch (asType) {
    case "generation":
      return new LangfuseGeneration({
        otelSpan,
        attributes
      });
    case "embedding":
      return new LangfuseEmbedding({
        otelSpan,
        attributes
      });
    case "agent":
      return new LangfuseAgent({
        otelSpan,
        attributes
      });
    case "tool":
      return new LangfuseTool({
        otelSpan,
        attributes
      });
    case "chain":
      return new LangfuseChain({
        otelSpan,
        attributes
      });
    case "retriever":
      return new LangfuseRetriever({
        otelSpan,
        attributes
      });
    case "evaluator":
      return new LangfuseEvaluator({
        otelSpan,
        attributes
      });
    case "guardrail":
      return new LangfuseGuardrail({
        otelSpan,
        attributes
      });
    case "event": {
      const timestamp = (_a = observationOptions == null ? void 0 : observationOptions.startTime) != null ? _a : /* @__PURE__ */ new Date();
      return new LangfuseEvent({
        otelSpan,
        attributes,
        timestamp
      });
    }
    case "span":
    default:
      return new LangfuseSpan({
        otelSpan,
        attributes
      });
  }
}
function startActiveObservation(name, fn, options) {
  var _a;
  const { asType = "span", ...observationOptions } = options || {};
  return getLangfuseTracer().startActiveSpan(
    name,
    { startTime: observationOptions == null ? void 0 : observationOptions.startTime },
    (_a = createParentContext(observationOptions == null ? void 0 : observationOptions.parentSpanContext)) != null ? _a : context.active(),
    (span) => {
      var _a2;
      try {
        let observation;
        switch (asType) {
          case "generation":
            observation = new LangfuseGeneration({
              otelSpan: span
            });
            break;
          case "embedding":
            observation = new LangfuseEmbedding({
              otelSpan: span
            });
            break;
          case "agent":
            observation = new LangfuseAgent({
              otelSpan: span
            });
            break;
          case "tool":
            observation = new LangfuseTool({
              otelSpan: span
            });
            break;
          case "chain":
            observation = new LangfuseChain({
              otelSpan: span
            });
            break;
          case "retriever":
            observation = new LangfuseRetriever({
              otelSpan: span
            });
            break;
          case "evaluator":
            observation = new LangfuseEvaluator({
              otelSpan: span
            });
            break;
          case "guardrail":
            observation = new LangfuseGuardrail({
              otelSpan: span
            });
            break;
          case "event": {
            const timestamp = (_a2 = observationOptions == null ? void 0 : observationOptions.startTime) != null ? _a2 : /* @__PURE__ */ new Date();
            observation = new LangfuseEvent({
              otelSpan: span,
              timestamp
            });
            break;
          }
          case "span":
          default:
            observation = new LangfuseSpan({
              otelSpan: span
            });
        }
        const result = fn(observation);
        if (result instanceof Promise) {
          return wrapPromise(
            result,
            span,
            observationOptions == null ? void 0 : observationOptions.endOnExit
          );
        } else {
          if ((observationOptions == null ? void 0 : observationOptions.endOnExit) !== false) {
            span.end();
          }
          return result;
        }
      } catch (err) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : "Unknown error"
        });
        if ((observationOptions == null ? void 0 : observationOptions.endOnExit) !== false) {
          span.end();
        }
        throw err;
      }
    }
  );
}
function updateActiveTrace(attributes) {
  const span = trace2.getActiveSpan();
  if (!span) {
    getGlobalLogger2().warn(
      "No active OTEL span in context. Skipping trace update."
    );
    return;
  }
  span.setAttributes(createTraceAttributes(attributes));
}
function updateActiveObservation(attributes, options) {
  var _a;
  const span = trace2.getActiveSpan();
  if (!span) {
    getGlobalLogger2().warn(
      "No active OTEL span in context. Skipping span update."
    );
    return;
  }
  const otelAttributes = createObservationAttributes(
    (_a = options == null ? void 0 : options.asType) != null ? _a : "span",
    attributes
  );
  if (!(options == null ? void 0 : options.asType)) {
    otelAttributes[LangfuseOtelSpanAttributes2.OBSERVATION_TYPE] = void 0;
  }
  span.setAttributes(otelAttributes);
}
function observe(fn, options = {}) {
  const {
    name = fn.name || "anonymous-function",
    asType = "span",
    captureInput = true,
    captureOutput = true,
    parentSpanContext = void 0
  } = options;
  const wrappedFunction = function(...args) {
    const inputData = captureInput ? _captureArguments(args) : void 0;
    const observation = startObservation(
      name,
      inputData ? { input: inputData } : {},
      {
        asType,
        // typecast necessary as ts cannot narrow down type
        parentSpanContext
      }
    );
    const activeContext = trace2.setSpan(context.active(), observation.otelSpan);
    try {
      const result = context.with(activeContext, () => fn.apply(this, args));
      if (result instanceof Promise) {
        return result.then(
          (value) => {
            if (captureOutput) {
              observation.update({ output: _captureOutput(value) });
            }
            if ((options == null ? void 0 : options.endOnExit) !== false) {
              observation.end();
            }
            return value;
          },
          (error) => {
            observation.update({
              level: "ERROR",
              statusMessage: (error instanceof Error ? error.message : String(error)) || "Function threw an error",
              output: captureOutput ? { error: String(error) } : void 0
            });
            if ((options == null ? void 0 : options.endOnExit) !== false) {
              observation.end();
            }
            throw error;
          }
        );
      } else {
        if (captureOutput) {
          observation.update({ output: _captureOutput(result) });
        }
        if ((options == null ? void 0 : options.endOnExit) !== false) {
          observation.end();
        }
        return result;
      }
    } catch (error) {
      observation.update({
        level: "ERROR",
        statusMessage: (error instanceof Error ? error.message : String(error)) || "Function threw an error",
        output: captureOutput ? { error: String(error) } : void 0
      });
      if ((options == null ? void 0 : options.endOnExit) !== false) {
        observation.end();
      }
      throw error;
    }
  };
  return wrappedFunction;
}
function _captureArguments(args) {
  try {
    if (args.length === 0) return void 0;
    if (args.length === 1) return args[0];
    return args;
  } catch {
    return "<failed to capture arguments>";
  }
}
function _captureOutput(value) {
  try {
    if (value === void 0 || value === null) return value;
    if (typeof value !== "object") return value;
    return value;
  } catch {
    return "<failed to capture output>";
  }
}
async function createTraceId(seed) {
  if (seed) {
    const data = new TextEncoder().encode(seed);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = new Uint8Array(hashBuffer);
    return uint8ArrayToHex(hashArray).slice(0, 32);
  }
  const randomValues = crypto.getRandomValues(new Uint8Array(16));
  return uint8ArrayToHex(randomValues);
}
function uint8ArrayToHex(array) {
  return Array.from(array).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function getActiveTraceId() {
  var _a;
  return (_a = trace2.getActiveSpan()) == null ? void 0 : _a.spanContext().traceId;
}
function getActiveSpanId() {
  var _a;
  return (_a = trace2.getActiveSpan()) == null ? void 0 : _a.spanContext().spanId;
}
export {
  LangfuseAgent,
  LangfuseChain,
  LangfuseEmbedding,
  LangfuseEvaluator,
  LangfuseEvent,
  LangfuseGeneration,
  LangfuseGuardrail,
  LangfuseOtelSpanAttributes3 as LangfuseOtelSpanAttributes,
  LangfuseRetriever,
  LangfuseSpan,
  LangfuseTool,
  createObservationAttributes,
  createTraceAttributes,
  createTraceId,
  getActiveSpanId,
  getActiveTraceId,
  getLangfuseTracer,
  getLangfuseTracerProvider,
  observe,
  setLangfuseTracerProvider,
  startActiveObservation,
  startObservation,
  updateActiveObservation,
  updateActiveTrace
};
//# sourceMappingURL=index.mjs.map