"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  LangfuseAgent: () => LangfuseAgent,
  LangfuseChain: () => LangfuseChain,
  LangfuseEmbedding: () => LangfuseEmbedding,
  LangfuseEvaluator: () => LangfuseEvaluator,
  LangfuseEvent: () => LangfuseEvent,
  LangfuseGeneration: () => LangfuseGeneration,
  LangfuseGuardrail: () => LangfuseGuardrail,
  LangfuseOtelSpanAttributes: () => import_core4.LangfuseOtelSpanAttributes,
  LangfuseRetriever: () => LangfuseRetriever,
  LangfuseSpan: () => LangfuseSpan,
  LangfuseTool: () => LangfuseTool,
  createObservationAttributes: () => createObservationAttributes,
  createTraceAttributes: () => createTraceAttributes,
  createTraceId: () => createTraceId,
  getActiveSpanId: () => getActiveSpanId,
  getActiveTraceId: () => getActiveTraceId,
  getLangfuseTracer: () => getLangfuseTracer,
  getLangfuseTracerProvider: () => getLangfuseTracerProvider,
  observe: () => observe,
  setLangfuseTracerProvider: () => setLangfuseTracerProvider,
  startActiveObservation: () => startActiveObservation,
  startObservation: () => startObservation,
  updateActiveObservation: () => updateActiveObservation,
  updateActiveTrace: () => updateActiveTrace
});
module.exports = __toCommonJS(index_exports);
var import_core3 = require("@langfuse/core");
var import_api2 = require("@opentelemetry/api");

// src/attributes.ts
var import_core = require("@langfuse/core");
function createTraceAttributes({
  name,
  userId,
  sessionId,
  version,
  release,
  input,
  output,
  metadata,
  tags,
  environment,
  public: isPublic
} = {}) {
  const attributes = {
    [import_core.LangfuseOtelSpanAttributes.TRACE_NAME]: name,
    [import_core.LangfuseOtelSpanAttributes.TRACE_USER_ID]: userId,
    [import_core.LangfuseOtelSpanAttributes.TRACE_SESSION_ID]: sessionId,
    [import_core.LangfuseOtelSpanAttributes.VERSION]: version,
    [import_core.LangfuseOtelSpanAttributes.RELEASE]: release,
    [import_core.LangfuseOtelSpanAttributes.TRACE_INPUT]: _serialize(input),
    [import_core.LangfuseOtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),
    [import_core.LangfuseOtelSpanAttributes.TRACE_TAGS]: tags,
    [import_core.LangfuseOtelSpanAttributes.ENVIRONMENT]: environment,
    [import_core.LangfuseOtelSpanAttributes.TRACE_PUBLIC]: isPublic,
    ..._flattenAndSerializeMetadata(metadata, "trace")
  };
  return Object.fromEntries(
    Object.entries(attributes).filter(([_, v]) => v != null)
  );
}
function createObservationAttributes(type, attributes) {
  const {
    metadata,
    input,
    output,
    level,
    statusMessage,
    version,
    completionStartTime,
    model,
    modelParameters,
    usageDetails,
    costDetails,
    prompt
  } = attributes;
  let otelAttributes = {
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_TYPE]: type,
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_LEVEL]: level,
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,
    [import_core.LangfuseOtelSpanAttributes.VERSION]: version,
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_MODEL]: model,
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_USAGE_DETAILS]: _serialize(usageDetails),
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_COST_DETAILS]: _serialize(costDetails),
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_COMPLETION_START_TIME]: _serialize(completionStartTime),
    [import_core.LangfuseOtelSpanAttributes.OBSERVATION_MODEL_PARAMETERS]: _serialize(modelParameters),
    ...prompt && !prompt.isFallback ? {
      [import_core.LangfuseOtelSpanAttributes.OBSERVATION_PROMPT_NAME]: prompt.name,
      [import_core.LangfuseOtelSpanAttributes.OBSERVATION_PROMPT_VERSION]: prompt.version
    } : {},
    ..._flattenAndSerializeMetadata(metadata, "observation")
  };
  return Object.fromEntries(
    Object.entries(otelAttributes).filter(([_, v]) => v != null)
  );
}
function _serialize(obj) {
  try {
    if (typeof obj === "string") return obj;
    return obj != null ? JSON.stringify(obj) : void 0;
  } catch {
    return "<failed to serialize>";
  }
}
function _flattenAndSerializeMetadata(metadata, type) {
  const prefix = type === "observation" ? import_core.LangfuseOtelSpanAttributes.OBSERVATION_METADATA : import_core.LangfuseOtelSpanAttributes.TRACE_METADATA;
  const metadataAttributes = {};
  if (metadata === void 0 || metadata === null) {
    return metadataAttributes;
  }
  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    const serialized = _serialize(metadata);
    if (serialized) {
      metadataAttributes[prefix] = serialized;
    }
  } else {
    for (const [key, value] of Object.entries(metadata)) {
      const serialized = typeof value === "string" ? value : _serialize(value);
      if (serialized) {
        metadataAttributes[`${prefix}.${key}`] = serialized;
      }
    }
  }
  return metadataAttributes;
}

// src/tracerProvider.ts
var import_core2 = require("@langfuse/core");
var import_api = require("@opentelemetry/api");
var LANGFUSE_GLOBAL_SYMBOL = Symbol.for("langfuse");
function createState() {
  return {
    isolatedTracerProvider: null
  };
}
function getGlobalState() {
  const initialState = createState();
  try {
    const g = globalThis;
    if (typeof g !== "object" || g === null) {
      (0, import_core2.getGlobalLogger)().warn(
        "globalThis is not available, using fallback state"
      );
      return initialState;
    }
    if (!g[LANGFUSE_GLOBAL_SYMBOL]) {
      Object.defineProperty(g, LANGFUSE_GLOBAL_SYMBOL, {
        value: initialState,
        writable: false,
        // lock the slot (not the contents)
        configurable: false,
        enumerable: false
      });
    }
    return g[LANGFUSE_GLOBAL_SYMBOL];
  } catch (err) {
    if (err instanceof Error) {
      (0, import_core2.getGlobalLogger)().error(`Failed to access global state: ${err.message}`);
    } else {
      (0, import_core2.getGlobalLogger)().error(`Failed to access global state: ${String(err)}`);
    }
    return initialState;
  }
}
function setLangfuseTracerProvider(provider) {
  getGlobalState().isolatedTracerProvider = provider;
}
function getLangfuseTracerProvider() {
  const { isolatedTracerProvider } = getGlobalState();
  if (isolatedTracerProvider) return isolatedTracerProvider;
  return import_api.trace.getTracerProvider();
}
function getLangfuseTracer() {
  return getLangfuseTracerProvider().getTracer(
    import_core2.LANGFUSE_TRACER_NAME,
    import_core2.LANGFUSE_SDK_VERSION
  );
}

// src/spanWrapper.ts
var LangfuseBaseObservation = class {
  constructor(params) {
    this.otelSpan = params.otelSpan;
    this.id = params.otelSpan.spanContext().spanId;
    this.traceId = params.otelSpan.spanContext().traceId;
    this.type = params.type;
    if (params.attributes) {
      this.otelSpan.setAttributes(
        createObservationAttributes(params.type, params.attributes)
      );
    }
  }
  /** Gets the Langfuse OpenTelemetry tracer instance */
  get tracer() {
    return getLangfuseTracer();
  }
  /**
   * Ends the observation, marking it as complete.
   *
   * @param endTime - Optional end time, defaults to current time
   */
  end(endTime) {
    this.otelSpan.end(endTime);
  }
  updateOtelSpanAttributes(attributes) {
    this.otelSpan.setAttributes(
      createObservationAttributes(this.type, attributes)
    );
  }
  /**
   * Updates the parent trace with new attributes.
   *
   * This sets trace-level attributes that apply to the entire trace,
   * not just this specific observation.
   *
   * @param attributes - Trace attributes to set
   * @returns This observation for method chaining
   */
  updateTrace(attributes) {
    this.otelSpan.setAttributes(createTraceAttributes(attributes));
    return this;
  }
  startObservation(name, attributes, options) {
    const { asType = "span" } = options || {};
    return startObservation(name, attributes, {
      asType,
      // typecast necessary as ts cannot narrow the type correctly
      parentSpanContext: this.otelSpan.spanContext()
    });
  }
};
var LangfuseSpan = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "span" });
  }
  /**
   * Updates this span with new attributes.
   *
   * @param attributes - Span attributes to set
   * @returns This span for method chaining
   *
   * @example
   * ```typescript
   * span.update({
   *   output: { result: 'success' },
   *   level: 'DEFAULT',
   *   metadata: { duration: 150 }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseAgent = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "agent" });
  }
  /**
   * Updates this agent observation with new attributes.
   *
   * @param attributes - Agent attributes to set
   * @returns This agent for method chaining
   *
   * @example
   * ```typescript
   * agent.update({
   *   output: {
   *     taskCompleted: true,
   *     iterationsUsed: 5,
   *     toolsInvoked: ['web-search', 'calculator', 'summarizer'],
   *     finalResult: 'Research completed with high confidence'
   *   },
   *   metadata: {
   *     efficiency: 0.85,
   *     qualityScore: 0.92,
   *     resourcesConsumed: { tokens: 15000, apiCalls: 12 }
   *   }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseTool = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "tool" });
  }
  /**
   * Updates this tool observation with new attributes.
   *
   * @param attributes - Tool attributes to set
   * @returns This tool for method chaining
   *
   * @example
   * ```typescript
   * tool.update({
   *   output: {
   *     result: searchResults,
   *     count: searchResults.length,
   *     relevanceScore: 0.89,
   *     executionTime: 1250
   *   },
   *   metadata: {
   *     cacheHit: false,
   *     apiCost: 0.025,
   *     rateLimitRemaining: 950
   *   }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseChain = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "chain" });
  }
  /**
   * Updates this chain observation with new attributes.
   *
   * @param attributes - Chain attributes to set
   * @returns This chain for method chaining
   *
   * @example
   * ```typescript
   * chain.update({
   *   output: {
   *     stepsCompleted: 5,
   *     stepsSuccessful: 4,
   *     finalResult: processedData,
   *     pipelineEfficiency: 0.87
   *   },
   *   metadata: {
   *     bottleneckStep: 'data-validation',
   *     parallelizationOpportunities: ['step-2', 'step-3'],
   *     optimizationSuggestions: ['cache-intermediate-results']
   *   }
   * });
   * ```
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseRetriever = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "retriever" });
  }
  /**
   * Updates this retriever observation with new attributes.
   *
   * @param attributes - Retriever attributes to set
   * @returns This retriever for method chaining
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseEvaluator = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "evaluator" });
  }
  /**
   * Updates this evaluator observation with new attributes.
   *
   * @param attributes - Evaluator attributes to set
   * @returns This evaluator for method chaining
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseGuardrail = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "guardrail" });
  }
  /**
   * Updates this guardrail observation with new attributes.
   *
   * @param attributes - Guardrail attributes to set
   * @returns This guardrail for method chaining
   */
  update(attributes) {
    super.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseGeneration = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "generation" });
  }
  update(attributes) {
    this.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseEmbedding = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "embedding" });
  }
  /**
   * Updates this embedding observation with new attributes.
   *
   * @param attributes - Embedding attributes to set
   * @returns This embedding for method chaining
   */
  update(attributes) {
    this.updateOtelSpanAttributes(attributes);
    return this;
  }
};
var LangfuseEvent = class extends LangfuseBaseObservation {
  constructor(params) {
    super({ ...params, type: "event" });
    this.otelSpan.end(params.timestamp);
  }
};

// src/index.ts
var import_core4 = require("@langfuse/core");
function createOtelSpan(params) {
  return getLangfuseTracer().startSpan(
    params.name,
    { startTime: params.startTime },
    createParentContext(params.parentSpanContext)
  );
}
function createParentContext(parentSpanContext) {
  if (!parentSpanContext) return;
  return import_api2.trace.setSpanContext(import_api2.context.active(), parentSpanContext);
}
function wrapPromise(promise, span, endOnExit) {
  return promise.then(
    (value) => {
      if (endOnExit !== false) {
        span.end();
      }
      return value;
    },
    (err) => {
      span.setStatus({
        code: import_api2.SpanStatusCode.ERROR,
        message: err instanceof Error ? err.message : "Unknown error"
      });
      if (endOnExit !== false) {
        span.end();
      }
      throw err;
    }
  );
}
function startObservation(name, attributes, options) {
  var _a;
  const { asType = "span", ...observationOptions } = options || {};
  const otelSpan = createOtelSpan({
    name,
    ...observationOptions
  });
  switch (asType) {
    case "generation":
      return new LangfuseGeneration({
        otelSpan,
        attributes
      });
    case "embedding":
      return new LangfuseEmbedding({
        otelSpan,
        attributes
      });
    case "agent":
      return new LangfuseAgent({
        otelSpan,
        attributes
      });
    case "tool":
      return new LangfuseTool({
        otelSpan,
        attributes
      });
    case "chain":
      return new LangfuseChain({
        otelSpan,
        attributes
      });
    case "retriever":
      return new LangfuseRetriever({
        otelSpan,
        attributes
      });
    case "evaluator":
      return new LangfuseEvaluator({
        otelSpan,
        attributes
      });
    case "guardrail":
      return new LangfuseGuardrail({
        otelSpan,
        attributes
      });
    case "event": {
      const timestamp = (_a = observationOptions == null ? void 0 : observationOptions.startTime) != null ? _a : /* @__PURE__ */ new Date();
      return new LangfuseEvent({
        otelSpan,
        attributes,
        timestamp
      });
    }
    case "span":
    default:
      return new LangfuseSpan({
        otelSpan,
        attributes
      });
  }
}
function startActiveObservation(name, fn, options) {
  var _a;
  const { asType = "span", ...observationOptions } = options || {};
  return getLangfuseTracer().startActiveSpan(
    name,
    { startTime: observationOptions == null ? void 0 : observationOptions.startTime },
    (_a = createParentContext(observationOptions == null ? void 0 : observationOptions.parentSpanContext)) != null ? _a : import_api2.context.active(),
    (span) => {
      var _a2;
      try {
        let observation;
        switch (asType) {
          case "generation":
            observation = new LangfuseGeneration({
              otelSpan: span
            });
            break;
          case "embedding":
            observation = new LangfuseEmbedding({
              otelSpan: span
            });
            break;
          case "agent":
            observation = new LangfuseAgent({
              otelSpan: span
            });
            break;
          case "tool":
            observation = new LangfuseTool({
              otelSpan: span
            });
            break;
          case "chain":
            observation = new LangfuseChain({
              otelSpan: span
            });
            break;
          case "retriever":
            observation = new LangfuseRetriever({
              otelSpan: span
            });
            break;
          case "evaluator":
            observation = new LangfuseEvaluator({
              otelSpan: span
            });
            break;
          case "guardrail":
            observation = new LangfuseGuardrail({
              otelSpan: span
            });
            break;
          case "event": {
            const timestamp = (_a2 = observationOptions == null ? void 0 : observationOptions.startTime) != null ? _a2 : /* @__PURE__ */ new Date();
            observation = new LangfuseEvent({
              otelSpan: span,
              timestamp
            });
            break;
          }
          case "span":
          default:
            observation = new LangfuseSpan({
              otelSpan: span
            });
        }
        const result = fn(observation);
        if (result instanceof Promise) {
          return wrapPromise(
            result,
            span,
            observationOptions == null ? void 0 : observationOptions.endOnExit
          );
        } else {
          if ((observationOptions == null ? void 0 : observationOptions.endOnExit) !== false) {
            span.end();
          }
          return result;
        }
      } catch (err) {
        span.setStatus({
          code: import_api2.SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : "Unknown error"
        });
        if ((observationOptions == null ? void 0 : observationOptions.endOnExit) !== false) {
          span.end();
        }
        throw err;
      }
    }
  );
}
function updateActiveTrace(attributes) {
  const span = import_api2.trace.getActiveSpan();
  if (!span) {
    (0, import_core3.getGlobalLogger)().warn(
      "No active OTEL span in context. Skipping trace update."
    );
    return;
  }
  span.setAttributes(createTraceAttributes(attributes));
}
function updateActiveObservation(attributes, options) {
  var _a;
  const span = import_api2.trace.getActiveSpan();
  if (!span) {
    (0, import_core3.getGlobalLogger)().warn(
      "No active OTEL span in context. Skipping span update."
    );
    return;
  }
  const otelAttributes = createObservationAttributes(
    (_a = options == null ? void 0 : options.asType) != null ? _a : "span",
    attributes
  );
  if (!(options == null ? void 0 : options.asType)) {
    otelAttributes[import_core3.LangfuseOtelSpanAttributes.OBSERVATION_TYPE] = void 0;
  }
  span.setAttributes(otelAttributes);
}
function observe(fn, options = {}) {
  const {
    name = fn.name || "anonymous-function",
    asType = "span",
    captureInput = true,
    captureOutput = true,
    parentSpanContext = void 0
  } = options;
  const wrappedFunction = function(...args) {
    const inputData = captureInput ? _captureArguments(args) : void 0;
    const observation = startObservation(
      name,
      inputData ? { input: inputData } : {},
      {
        asType,
        // typecast necessary as ts cannot narrow down type
        parentSpanContext
      }
    );
    const activeContext = import_api2.trace.setSpan(import_api2.context.active(), observation.otelSpan);
    try {
      const result = import_api2.context.with(activeContext, () => fn.apply(this, args));
      if (result instanceof Promise) {
        return result.then(
          (value) => {
            if (captureOutput) {
              observation.update({ output: _captureOutput(value) });
            }
            if ((options == null ? void 0 : options.endOnExit) !== false) {
              observation.end();
            }
            return value;
          },
          (error) => {
            observation.update({
              level: "ERROR",
              statusMessage: (error instanceof Error ? error.message : String(error)) || "Function threw an error",
              output: captureOutput ? { error: String(error) } : void 0
            });
            if ((options == null ? void 0 : options.endOnExit) !== false) {
              observation.end();
            }
            throw error;
          }
        );
      } else {
        if (captureOutput) {
          observation.update({ output: _captureOutput(result) });
        }
        if ((options == null ? void 0 : options.endOnExit) !== false) {
          observation.end();
        }
        return result;
      }
    } catch (error) {
      observation.update({
        level: "ERROR",
        statusMessage: (error instanceof Error ? error.message : String(error)) || "Function threw an error",
        output: captureOutput ? { error: String(error) } : void 0
      });
      if ((options == null ? void 0 : options.endOnExit) !== false) {
        observation.end();
      }
      throw error;
    }
  };
  return wrappedFunction;
}
function _captureArguments(args) {
  try {
    if (args.length === 0) return void 0;
    if (args.length === 1) return args[0];
    return args;
  } catch {
    return "<failed to capture arguments>";
  }
}
function _captureOutput(value) {
  try {
    if (value === void 0 || value === null) return value;
    if (typeof value !== "object") return value;
    return value;
  } catch {
    return "<failed to capture output>";
  }
}
async function createTraceId(seed) {
  if (seed) {
    const data = new TextEncoder().encode(seed);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = new Uint8Array(hashBuffer);
    return uint8ArrayToHex(hashArray).slice(0, 32);
  }
  const randomValues = crypto.getRandomValues(new Uint8Array(16));
  return uint8ArrayToHex(randomValues);
}
function uint8ArrayToHex(array) {
  return Array.from(array).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function getActiveTraceId() {
  var _a;
  return (_a = import_api2.trace.getActiveSpan()) == null ? void 0 : _a.spanContext().traceId;
}
function getActiveSpanId() {
  var _a;
  return (_a = import_api2.trace.getActiveSpan()) == null ? void 0 : _a.spanContext().spanId;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LangfuseAgent,
  LangfuseChain,
  LangfuseEmbedding,
  LangfuseEvaluator,
  LangfuseEvent,
  LangfuseGeneration,
  LangfuseGuardrail,
  LangfuseOtelSpanAttributes,
  LangfuseRetriever,
  LangfuseSpan,
  LangfuseTool,
  createObservationAttributes,
  createTraceAttributes,
  createTraceId,
  getActiveSpanId,
  getActiveTraceId,
  getLangfuseTracer,
  getLangfuseTracerProvider,
  observe,
  setLangfuseTracerProvider,
  startActiveObservation,
  startObservation,
  updateActiveObservation,
  updateActiveTrace
});
//# sourceMappingURL=index.cjs.map